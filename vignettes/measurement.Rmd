---
title: "The Measurement Properties of Electoral Contestation"
header-includes:
    - \usepackage{setspace}\onehalfspacing
author: "Chris Weber"
date: "2025-03-03"
indent: true
output:
  pdf_document: default
---

## Introduction

We begin with a descriptive question: What types of actions do Americans deem acceptable when someone disagrees with the results of an election? Here we focus on levels of support for various actions such as protesting, criticizing election integrity, burning the American flag, ballot recounts, or challenging the outcome in the courts. Moreover, we are interested in understanding the underlying structure of contestation preferences. Is a construct like contestation multidimensional?

On one hand, we might expect that contestation behaviors reside on a single underlying dimension, anchored by a preference for contestation behaviors on one pole, and an opposition to these behaviors at the other pole. However, there are several reasons to expect more nuance, due primarily to different norms surrounding such behaviors. For instance, while recounting ballots and supporting legal means to contest an election are common and generally perceived-to-be acceptable behaviors, attending a march or burning the flag are seen as more active and potentially transgressive behaviors. Contestation behaviors may be effectively disaggregated into forms that pose a relatively high cost for individual citizens (i.e, require action) versus forms of contestation that are passive and impose a low cost for citizens. They can also be viewed as a continuum of behaviors that range from less to more normatively acceptable.

\subsection{Measuring Support for Contestation Behaviors}

We measure support for behaviors aimed at contesting election results with a question battery that captures some of the most prominent ways election results are contested. Respondents were asked,

``Many people are unhappy with the outcomes of elections. How much do you support or oppose each of the following behaviors when people are unhappy with the outcome of an election?''

$\bullet$ Attend a march or demonstration (WSS20[1/2], WSS24, AVPW1, AVPW2, ASU, BYU)

$\bullet$ Burning the American flag (WSS20, WSS24, AVPW1, AVPW2, ASU, BYU)

$\bullet$ Contest the outcome in the courts (WSS20, WSS24, AVPW1, AVPW2, ASU, BYU)

$\bullet$ Support ballot recounts (WSS20, WSS24, AVPW1, AVPW2, ASU, BYU)

$\bullet$ Publicly criticize the integrity or fairness of the election (WSS20[1/2], WSS24, AVPW1, AVPW2, ASU, BYU)

$\bullet$ Engaging in violent acts (WSS24, ASU[Pre], BYU [Post, Control])

$\bullet$ Public officials choosing to certify the election results (AVPW1, AVPW2)

$\bullet$ Refusing to concede an election defeat (AVPW1, AVPW2)

$\bullet$ Call a new election (AVPW1, AVPW2)

$\bullet$ Undermine the election process (WSS24)



Respondents were asked to rate their support for each behavior on a 5-point scale, ranging from 1 (strongly support) to 5 (strongly oppose).

## Recoding and Scaling

We rely on six data sets in this project. The **Western States Survey** conducted in both 2020 and 2024. The **Arizona Voter Project** election surveys, conducted in 2023 and 2024. And the 2022 Congressional Election Study BYU module and the 2022 Congressional Election Study ASU module.

The $\texttt{electoralContestation}$ package includes a number of helper functions to clean and recode these data. Downloading the package comes with the data $\texttt{electoral\_contestation}$. The total data size is approximately 11,000 respondents.

The data can be downloaded by accessing the package 
```
devtools::install_github("crweber9874\/electoralContestation")
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
rm(list = ls())
# Install from repository
#devtools::install_github("crweber9874/electoralContestation")
library(electoralContestation)
library(dplyr)
library(lavaan)
library(ggplot2)
library(cowplot)
```

You should be able to estimate everything below, by simply the package.


## Models 

In structural equation modeling, full information maximum likelihood (FIML) is frequently used when data are Missing At Random (MAR). FIML involves calculating the likelihood function based on the observed data, then it integrates out the missing values. The likelihood is calculated based on the information available. Insofar as the data are "missing at random" (MAR), FIML can be a useful way in an SEM to handle missing data, and it's not altogether different from the assumptions underlying imputation methods. I am basically using all the information available, across the six studies, using nine contestation items.

Here is how this is done in lavaan. Let's just print out the output for a two factor model, and then we can look at the eigenvalues to see how many factors we should retain.

## Two Factor Model
```{r}
fit <- suppressWarnings(efa(data = electoral_contestation[,c(
                                                       "violent",
                                                       "concede",
                                                       "criticize_election",
                                                       "attend_march",
                                                       "court",
                                                       "recount",
                                                       "new_election",
                                                       "undermine",
                                                       "state_certify",
                                                       "certify_occupy"
                                                       )],
                            nfactors = 2,
                            missing = "fiml",
                           output = "lavaan"
           ))

summary(fit, fit.measures = TRUE, standardized = TRUE)

```

The two factor model fits well, and the scree plots below supports a two factor solution.

## Factor Structure

```{r}
fit <- suppressWarnings(efa(data = electoral_contestation[,c("violent",
                                                       "state_certify",
                                                       "concede",
                                                       "criticize_election",
                                                       "attend_march",
                                                       "court",
                                                       "undermine",
                                                       "recount",
                                                       "new_election",
                                                       "certify_occupy")],
                            nfactors = 3,
                            missing = "fiml",
           ))
                                                       
eigenvalues = summary(fit)[[10]]$nf2[[1]]$eigvals[[1]]

eigen_df <- data.frame(
  Factor = 1:length(eigenvalues),
  Eigenvalue = eigenvalues
)


# Scree plot using ggplot2 (dots connected by lines)
scree_plot <- ggplot(eigen_df, aes(x = Factor, y = Eigenvalue)) +
  geom_line(alpha = 0.6) +  # Connect the dots with lines
  geom_point(size = 6, alpha = 0.3, color = "black") + # Add dots at each point
  labs(
    title = "Electoral Contestation\nScree Plot",
    x = "Factors",
    y = "Eigenvalue"
  ) +
  theme_minimal() + 
  # style a hell of lot better
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14),
    plot.title = element_text(size = 16)
  ) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgrey")

scree_plot
```

The two factor makes sense here -- both eigenvalues exceed the (arbitrary) cut point and the "elbow" is also at 2. Here's the fit for a confirmatory factor model, following this structure

```{r}
library(dplyr)
library(lavaan)
library(tidyr)
  ggtheme =
    theme(
      plot.title =  ggplot2::element_text(face = "bold", hjust = 0, vjust = 0, colour = "#3C3C3C", size = 12),
      axis.text.x = ggplot2::element_text(size = 12, colour = "#535353"),
      axis.text.y = ggplot2::element_text(size = 12, colour = "#535353"),
      axis.title =  ggplot2::element_text(size = 12, colour = "#535353"),
      axis.title.y = ggplot2::element_text(size = 12, colour = "#535353", vjust = 1.5),
      # Change facet
#      strip.background = ggplot2::element_rect(fill = "#D0D0D0", colour = "#D0D0D0"),
      axis.ticks = ggplot2::element_blank(),
      panel.grid.major = ggplot2::element_line(colour = "#D0D0D0", size = .25),
      panel.background = ggplot2::element_rect(fill = "white"),
      legend.text = ggplot2::element_text(size = 10),
      legend.title = ggplot2::element_text(size = 10),
      # chnge facet wrap label size
      )



  # & {Subversive Contestation} & {Traditional Contestation} \\
  # \midrule
  # \textit{Engaging in violent acts} & -0.253 & \textbf{0.630 }\\
  # \textit{Refusing to Concede the Election} & 0.026 & \textbf{0.885} \\
  # \textit{Publicly criticize the integrity or fairness of the election} & \textbf{0.389 }&\textbf{ 0.649} \\
  # \textit{Attend a march or demonstration} & \textbf{0.549 }& -0.132 \\
  # \textit{Contest the outcome in the courts} & \textbf{0.798} & 0.129 \\
  # \textit{Support election recounts} &\textbf{ 0.590} & 0.010 \\
  # \textit{Call a new election} & 0.215 &\textbf{ 0.674} \\
  # \textit{Undermine the election process} & 0.147 & \textbf{0.700} \\
  # \textit{State officials refusing to certify the election results} & -0.004 & \textbf{0.872} \\
  # \textit{Occupy} & -0.168 & 0.741 \\
  # 

electoral_contestation %>%
  select(violent, state_certify, concede, criticize_election, 
        attend_march, court, recount, new_election, 
        undermine, certify_occupy) %>%
  # rename the variables for clarity
  rename(`Engage in Violence` = violent,
         `Refuse to Certify` = state_certify,
         `Refuse to Concede` = concede,
         `Criticize Election` = criticize_election,
         `Attend a\nMarch or Rally` = attend_march,
         `Court` = court,
         `Recounts` = recount,
         `Call a New Election` = new_election,
         `Object to Eligibility` = undermine,
         `Occupy Buildings` = certify_occupy) %>%
  # pivot long
  pivot_longer(cols = everything(), names_to = "variable", values_to = "value")  %>%
  ggplot(aes(x = value)) +
  ggtheme + 
    facet_wrap(~variable, ncol = 4) + 
  geom_histogram(aes(y = ..density..), binwidth = 1, 
                 fill = "grey", color = "darkgrey",
                 alpha = 0.3) +
  geom_density(color = "darkblue", bw = 0.5) +
 theme(strip.text = element_text(size = 11),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
) + 
  labs(title = "Electoral Contestation\nDistribution of Responses",
       x = "Disagree-Agree",
       y = "Density")
ggsave("electoral_contestation_histograms.png", width = 8, height = 8, dpi = 500)
```
```{r}
library(ggplot2)
library(reshape2)
vars = c("state_certify", "concede","criticize_election",
         "attend_march", "court",  "recount", "new_election", 
         "undermine", "violent", "certify_occupy") 

electoral_contestation %>%
  select(all_of(vars)) %>%
  # deal with NA
  cor(use = "pairwise.complete.obs")


vars <- c("state_certify", "concede", "criticize_election", "attend_march", "court", 
          "recount", "new_election", "undermine", "violent", "certify_occupy")

library(tidyverse)
library(reshape2)

# Assuming 'electoral_contestation' is your data frame

correlation_matrix <- electoral_contestation %>%
  rename(`Engage in Violence` = violent,
         `Refuse to Certify` = state_certify,
         `Refuse to Concede` = concede,
         `Criticize Election` = criticize_election,
         `Attend March` = attend_march,
         `Court` = court,
         `Recounts` = recount,
         `Call a New Election` = new_election,
         `Object to Eligibility` = undermine,
         `Occupy Buildings` = certify_occupy) %>%
  select(`Engage in Violence`, `Refuse to Certify`, `Refuse to Concede`, 
         `Criticize Election`, `Attend March`, `Court`, 
         `Recounts`, `Call a New Election`, `Object to Eligibility`, 
         `Occupy Buildings`) %>%
  cor(use = "pairwise.complete.obs")

# Reorder the correlation matrix using hierarchical clustering
hc <- hclust(dist(correlation_matrix))
reordered_vars <- rownames(correlation_matrix)[hc$order]
reordered_matrix <- correlation_matrix[reordered_vars, reordered_vars]

correlation_long <- melt(reordered_matrix)

# Create the heatmap
heatmap_plot <- ggplot(data = correlation_long, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile() +
  scale_fill_gradient2(low = "white", mid = "white", high = "black", 
                       midpoint = 0, limit = c(-1, 1), space = "Lab", 
                       name="Pearson\nCorrelation") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 10, hjust = 1)) +
  coord_fixed() + 
  labs(title = "Electoral Contestation") + 
  xlab("Contestation Items") +
  ylab("Contestation Items")

heatmap_plot
ggsave("corr.png", width = 8, height = 8, dpi = 500)

```
```{r}
library(dplyr)
library(lavaan)

electoral_contestation %>%
  mutate(year = ifelse(survey == "wss20", 2020,
                       ifelse(survey == "wss24", 2024,
                              ifelse(survey == "avpw1", 2023,
                                     ifelse(survey == "avpw2", 2024,
                                            ifelse(survey == "cesBYU", 2022,
                                                   ifelse(survey == "cesASU", 2022,
                                                          NA)))))),  
    post2022 = abs(as.numeric(year > 2022)),
         authoritarianism = rowMeans(electoral_contestation[, c("auth_1", "auth_2",
                                                                 "auth_3", "auth_4")], na.rm = TRUE),
         trump_voter = ifelse(presvote_trump_2020 == 1, 1, 0),
         trump_voter = ifelse(is.na(trump_voter), presvote_trump_2024, trump_voter),
         trumpXauthoritarianism = trump_voter * authoritarianism
  ) -> dat

model <- "f1 =~ violent + state_certify + concede + criticize_election + new_election + undermine +        certify_occupy
          f2 =~ attend_march + court + recount"


# model = paste(model, 
#               "f1 ~", "trump_voter", "\n",
#               "f2 ~", "trump_voter"
#               )

# Perform multiple group CFA with measurement invariance constraints
fit_multi <- suppressWarnings(sem(model,
                                 data = dat,
                                 # group = "trump_voter",
                                 # group.equal = c("loadings", "intercepts", "residuals"),
                                 missing = "fiml"))

# This is somewhat clunky with fiml
factor_scores <- lavPredict(fit_multi, method = "regression")
factor_scores_df <- as.data.frame(factor_scores)
factor_scores_df$row_id <- as.integer(rownames(factor_scores_df))
# Hack by creating a row id and then join
electoral_contestation$row_id <- 1:nrow(electoral_contestation)
electoral_contestation_with_scores <- left_join(electoral_contestation, factor_scores_df, by = "row_id")
electoral_contestation_fscors <- electoral_contestation_with_scores %>% select(-row_id)
```

```{r}
# estimate a BRMS Model regressing y1 and y2 correlated on trump_voter
library(brms)
# Create a new data frame with the factor scores
electoral_contestation_fscors %>%
  mutate(post2022 = ifelse(year>2022, 1, 0),
         authoritarianism = rowMeans(electoral_contestation[, c("auth_1", "auth_2",
                                                                 "auth_3", "auth_4")], 
                                     na.rm = TRUE),
         trump_voter = ifelse(presvote_trump_2020 == 1, 1, 0),
         trump_voter = ifelse(is.na(trump_voter), presvote_trump_2024, trump_voter),
         trumpXauthoritarianism = trump_voter * authoritarianism,
         trump_voter = as.factor(trump_voter),
         pid = zero.one(party_identification7),
         extremity = zero.one(abs(4-party_identification7)),
         conservative = ifelse(ideology5 == 4 | ideology5 == 5, 1, 0),
         liberal = ifelse(ideology5 == 1 | ideology5 == 2, 1, 0),
         moderate = ifelse(ideology5 == 4 , 1, 0)) -> dat
  
  
# Fit the model
fit_brms <- brm(
    bf(f2 ~ trump_voter + black + latino + white + college + faminc + female + authoritarianism + post2022 + trump_voter:post2022) + 
    bf(f1 ~ trump_voter + black + latino + white + college + faminc + female + authoritarianism + post2022 + trump_voter:post2022),  
  data = dat,
  family = gaussian(),
  iter = 2000,
  chains = 4,
  cores = 10,
)
summary(fit_brms)
```
```{r}
library(modelr)
library(tidybayes)
library(haven)
library(reshape2)

electoral_contestation %>% 
    mutate(post2020 = ifelse(year>2022, 1, 0),
           authoritarianism = rowMeans(electoral_contestation[, 
                                                            c("auth_1", "auth_2",
                                                              "auth_3", "auth_4")], na.rm = TRUE),
         trump_voter = ifelse(presvote_trump_2020 == 1, 1, 0),
         trump_voter = ifelse(is.na(trump_voter), 
                              presvote_trump_2024, trump_voter),
         trumpXauthoritarianism = trump_voter * authoritarianism) %>%
  data_grid(
        female  = mean(female,  na.rm = TRUE), 
        college = mean(college, na.rm = TRUE), 
        faminc  = mean(faminc,  na.rm = TRUE),
        black   = mean(black,   na.rm = TRUE), 
        latino  = mean(latino,  na.rm = TRUE), 
        white   = mean(white,   na.rm = TRUE), 
        authoritarianism = seq_range(authoritarianism, n = 2),
        trump_voter = c(0,1),
        post2022    = c(0,1))   %>%
      add_epred_draws(fit_brms) %>% 
      group_by(trump_voter, post2022, .category)  %>%
  summarize(
    factor_score = mean(.epred),
    .lower = quantile(.epred, 0.025),
    .upper = quantile(.epred, 0.975)
  ) %>%
  mutate(
    trump_voter = ifelse(trump_voter == 1, "Trump Voter", "Non-Trump Voter"),
    post2022 = ifelse(post2022 == 1, "2023-2024", "2020-2022"),
    factor = ifelse(.category == "f1", "Subversive", "Traditional"))  %>%
   ggplot(aes(x = as.factor(post2022),
                  y = factor_score, 
                  ymin=.lower, 
                  ymax=.upper,
                  group = factor,
                  color = factor
             ))+
facet_wrap(~ as.factor(trump_voter) ) +
  geom_point(size=4, alpha = 0.3, position = position_dodge(width = 0.2)) +
  geom_errorbar(width = 0.10, alpha=0.75, colour = "black", position = position_dodge(width = 0.2)) +
  ggtitle("Electoral Contestation\nBy Voting and Survey Year") +
  scale_y_continuous("Factor Score")+
  scale_x_discrete("Survey") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14)
  )+
  # legend
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        legend.text = element_text(size = 10),
        legend.key.size = unit(0.5, "cm"),
        legend.key.width = unit(1, "cm")) +
  # change colors
  scale_color_manual(values = c("Subversive" = "black", "Traditional" = "grey")) 

ggsave("electoral_contestation_brms_trump.png", width = 8, height = 6, dpi = 500)

```




```{r}
# estimate a BRMS Model regressing y1 and y2 correlated on trump_voter
library(brms)
# Create a new data frame with the factor scores
electoral_contestation_fscors %>%
  mutate(post2022 = ifelse(year>2022, 1, 0),
         authoritarianism = rowMeans(electoral_contestation[, c("auth_1", "auth_2",
                                                                 "auth_3", "auth_4")], 
                                     na.rm = TRUE),
         trump_voter = ifelse(presvote_trump_2020 == 1, 1, 0),
         trump_voter = ifelse(is.na(trump_voter), presvote_trump_2024, trump_voter),
         trumpXauthoritarianism = trump_voter * authoritarianism,
         trump_voter = as.factor(trump_voter),
         pid = zero.one(party_identification7),
         extremity = zero.one(abs(4-party_identification7)),
         conservative = ifelse(ideology5 == 4 | ideology5 == 5, 1, 0),
         liberal = ifelse(ideology5 == 1 | ideology5 == 2, 1, 0),
         moderate = ifelse(ideology5 == 4 , 1, 0)) -> dat
  
  
# Fit the model
fit_brms <- brm(
    bf(f2 ~ trump_voter + black + latino + white + college + faminc + female + authoritarianism + post2022 + trump_voter:post2022) + 
    bf(f1 ~ trump_voter + black + latino + white + college + faminc + female + authoritarianism + post2022 + trump_voter:post2022),  
  data = dat,
  family = gaussian(),
  iter = 2000,
  chains = 4,
  cores = 10,
)
summary(fit_brms)
```


```{r}
# Fit the model
fit_brms <- brm(
    bf(f2 ~ extremity + pid + black + latino + white + college + faminc + female + 
            authoritarianism + post2022 + pid:post2022 + extremity:post2022) + 
    bf(f1 ~ extremity + pid + black + latino + white + college + faminc + female + 
            authoritarianism + post2022 + pid:post2022 + extremity:post2022),
  data = dat,
  family = gaussian(),
  iter = 2000,
  chains = 4,
  cores = 10,
)
```

```{r}
library(modelr)
library(tidybayes)
library(haven)
library(reshape2)

electoral_contestation %>% 
  mutate(post2022 = ifelse(year>2022, 1, 0),
         authoritarianism = rowMeans(electoral_contestation[, c("auth_1", "auth_2",
                                                                 "auth_3", "auth_4")], 
                                     na.rm = TRUE),
         trump_voter = ifelse(presvote_trump_2020 == 1, 1, 0),
         trump_voter = ifelse(is.na(trump_voter), presvote_trump_2024, trump_voter),
         trumpXauthoritarianism = trump_voter * authoritarianism,
         trump_voter = as.factor(trump_voter),
         pid = zero.one(party_identification7),
         extremity = zero.one(abs(4-party_identification7)),
         conservative = ifelse(ideology5 == 4 | ideology5 == 5, 1, 0),
         liberal = ifelse(ideology5 == 1 | ideology5 == 2, 1, 0),
         moderate = ifelse(ideology5 == 4 , 1, 0)) %>%
data_grid(
        female  = mean(female,  na.rm = TRUE), 
        college = mean(college, na.rm = TRUE), 
        faminc  = mean(faminc,  na.rm = TRUE),
        black   = mean(black,   na.rm = TRUE), 
        latino  = mean(latino,  na.rm = TRUE), 
        white   = mean(white,   na.rm = TRUE), 
        authoritarianism = seq_range(authoritarianism, n = 2),
        pid = seq_range(pid, n = 7),
        post2022    = c(0,1),
        extremity = mean(extremity, na.rm = TRUE))   %>%
      add_epred_draws(fit_brms) %>% 
      group_by(pid, post2022, .category)  %>%
  summarize(
    factor_score = mean(.epred),
    .lower = quantile(.epred, 0.025),
    .upper = quantile(.epred, 0.975)
  ) %>%
  mutate(
    post2022 = ifelse(post2022 == 1, "2023-2024", "2020-2022"),
    factor = ifelse(.category == "f1", "Subversive", "Traditional")
    )  %>%
   ggplot(aes(x = as.numeric(pid),
                  y = factor_score, 
                  ymin=.lower, 
                  ymax=.upper,
                  group = factor,
                  color = factor
             ))+
facet_wrap(~ as.factor(post2022) ) +
  geom_point(size=4, alpha = 0.3) +
  geom_errorbar(width = 0.01, alpha=0.75, colour = "black") +
  geom_line() + 
  ggtitle("Electoral Contestation\nBy Party Identification and Survey Year") +
  scale_y_continuous("Factor Score")+
  scale_x_continuous("Party Identification [0 = Strong Democrat, 1 = Strong Republican]") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14)
  )+
  # legend
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        legend.text = element_text(size = 10),
        legend.key.size = unit(0.5, "cm"),
        legend.key.width = unit(1, "cm")) +
  scale_color_manual(values = c("Subversive" = "black", "Traditional" = "grey")) 
  #
ggsave("electoral_contestation_brms_pid.png", width = 8, height = 6, dpi = 500)
```


```{r}
library(modelr)
library(tidybayes)
library(haven)
library(reshape2)

electoral_contestation %>% 
  mutate(post2022 = ifelse(year>2022, 1, 0),
         authoritarianism = rowMeans(electoral_contestation[, c("auth_1", "auth_2",
                                                                 "auth_3", "auth_4")], 
                                     na.rm = TRUE),
         trump_voter = ifelse(presvote_trump_2020 == 1, 1, 0),
         trump_voter = ifelse(is.na(trump_voter), presvote_trump_2024, trump_voter),
         trumpXauthoritarianism = trump_voter * authoritarianism,
         trump_voter = as.factor(trump_voter),
         pid = zero.one(party_identification7),
         extremity = zero.one(abs(4-party_identification7)),
         conservative = ifelse(ideology5 == 4 | ideology5 == 5, 1, 0),
         liberal = ifelse(ideology5 == 1 | ideology5 == 2, 1, 0),
         moderate = ifelse(ideology5 == 4 , 1, 0)) %>%
data_grid(
        female  = mean(female,  na.rm = TRUE), 
        college = mean(college, na.rm = TRUE), 
        faminc  = mean(faminc,  na.rm = TRUE),
        black   = mean(black,   na.rm = TRUE), 
        latino  = mean(latino,  na.rm = TRUE), 
        white   = mean(white,   na.rm = TRUE), 
        authoritarianism = seq_range(authoritarianism, n = 2),
        pid = mean(pid, na.rm = TRUE),
        post2022    = c(0,1),
        extremity = seq_range(extremity, n = 5))   %>%
      add_epred_draws(fit_brms) %>% 
      group_by(extremity, post2022, .category)  %>%
  summarize(
    factor_score = mean(.epred),
    .lower = quantile(.epred, 0.025),
    .upper = quantile(.epred, 0.975)
  ) %>%
  mutate(
    post2022 = ifelse(post2022 == 1, "2023-2024", "2020-2022"),
    factor = ifelse(.category == "f1", "Subversive", "Traditional")
    )  %>%
   ggplot(aes(x = as.numeric(extremity),
                  y = factor_score, 
                  ymin=.lower, 
                  ymax=.upper,
                  group = factor,
                  color = factor
             ))+
facet_wrap(~ as.factor(post2022) ) +
  geom_point(size=4, alpha = 0.3) +
  geom_errorbar(width = 0.01, alpha=0.75, colour = "black") +
  geom_line() + 
  ggtitle("Electoral Contestation\nBy Party Extremity and Survey Year") +
  scale_y_continuous("Factor Score")+
  scale_x_continuous("Party Extremity [0 =  Moderate, 1 = Extreme]") +
  theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14)
  )+
  # legend
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        legend.text = element_text(size = 10),
        legend.key.size = unit(0.5, "cm"),
        legend.key.width = unit(1, "cm")) +
  scale_color_manual(values = c("Subversive" = "black", "Traditional" = "grey")) 
  #
ggsave("electoral_contestation_brms_extremity.png", width = 8, height = 6, dpi = 500)
```



```{r}
library(electoralContestation)
library(dplyr)
library(lavaan)
library(ggplot2)
library(cowplot)

fit <- suppressWarnings(efa(data = electoral_contestation[,c(
                                                       "violent",
                                                       "concede",
                                                       "criticize_election",
                                                       "attend_march",
                                                       "court",
                                                       "recount",
                                                       "new_election",
                                                       "undermine",
                                                       "state_certify",
                                                       "certify_occupy",
                                                       "voteconfidence",
                                                       "free_fair"
                                                       )],
                            nfactors = 3,
                            missing = "fiml",
                           output = "lavaan"
           ))

summary(fit, fit.measures = TRUE)
```

library(dplyr)
library(lavaan)

# Assuming 'dat' and 'model' are already defined

# Configural Invariance (baseline)
fit_configural <- suppressWarnings(sem(model,
                                      data = dat,
                                      group = "trump_voter",
                                      missing = "fiml"))

# Metric Invariance (loadings constrained)
fit_metric <- suppressWarnings(sem(model,
                                  data = dat,
                                  group = "trump_voter",
                                  group.equal = c("loadings"),
                                  missing = "fiml"))

# Scalar Invariance (loadings and intercepts constrained)
fit_scalar <- suppressWarnings(sem(model,
                                  data = dat,
                                  group = "trump_voter",
                                  group.equal = c("loadings", "intercepts"),
                                  missing = "fiml"))

# Strict Invariance (loadings, intercepts, and residuals constrained)
fit_strict <- suppressWarnings(sem(model,
                                  data = dat,
                                  group = "trump_voter",
                                  group.equal = c("loadings", "intercepts", "residuals"),
                                  missing = "fiml"))

# Partial Metric Invariance (constrain all but 1 or 2 loadings)
partial_metric_1 <- suppressWarnings(sem(model,
                                          data = dat,
                                          group = "trump_voter",
                                          group.equal = c("loadings"),
                                          group.partial = list(list("f1 =~ violent")), # Free violent loading
                                          missing = "fiml"))

partial_metric_2 <- suppressWarnings(sem(model,
                                          data = dat,
                                          group = "trump_voter",
                                          group.equal = c("loadings"),
                                          group.partial = list(list("f1 =~ violent", "f2 =~ attend_march")), # Free violent and attend_march loadings
                                          missing = "fiml"))

# Partial Scalar Invariance (constrain all but 1 or 2 intercepts)
partial_scalar_1 <- suppressWarnings(sem(model,
                                          data = dat,
                                          group = "trump_voter",
                                          group.equal = c("loadings", "intercepts"),
                                          group.partial = list(list("violent~1")), # Free violent intercept
                                          missing = "fiml"))

partial_scalar_2 <- suppressWarnings(sem(model,
                                          data = dat,
                                          group = "trump_voter",
                                          group.equal = c("loadings", "intercepts"),
                                          group.partial = list(list("violent~1", "attend_march~1")), # Free violent and attend_march intercepts
                                          missing = "fiml"))

# Compare models
anova_config_metric <- anova(fit_configural, fit_metric)
anova_metric_scalar <- anova(fit_metric, fit_scalar)
anova_scalar_strict <- anova(fit_scalar, fit_strict)
anova_metric_partial1 <- anova(fit_metric, partial_metric_1)
anova_metric_partial2 <- anova(fit_metric, partial_metric_2)
anova_scalar_partial1 <- anova(fit_scalar, partial_scalar_1)
anova_scalar_partial2 <- anova(fit_scalar, partial_scalar_2)

# Print results
print(anova_config_metric)
print(anova_metric_scalar)
print(anova_scalar_strict)
print(anova_metric_partial1)
print(anova_metric_partial2)
print(anova_scalar_partial1)
print(anova_scalar_partial2)

# Summarize model fits
summary(fit_configural, fit.measures = TRUE)
summary(fit_metric, fit.measures = TRUE)
summary(fit_scalar, fit.measures = TRUE)
summary(fit_strict, fit.measures = TRUE)
summary(partial_metric_1, fit.measures = TRUE)
summary(partial_metric_2, fit.measures = TRUE)
summary(partial_scalar_1, fit.measures = TRUE)
summary(partial_scalar_2, fit.measures = TRUE)

# Compare model fits using anova()
anova_config_metric <- anova(fit_configural, fit_metric)
anova_metric_scalar <- anova(fit_metric, fit_scalar)
anova_scalar_strict <- anova(fit_scalar, fit_strict)

# Print results
print(anova_config_metric)
print(anova_metric_scalar)
print(anova_scalar_strict)

# # Also look at the model fit statistics
# summary(fit_configural, fit.measures = TRUE)
# summary(fit_metric, fit.measures = TRUE)
# summary(fit_scalar, fit.measures = TRUE)
# summary(fit_strict, fit.measures = TRUE)
```



electoral_contestation %>%
  mutate(post2020 = abs(as.numeric(year > 2020)),
         authoritarianism = rowMeans(electoral_contestation[, c("auth_1", "auth_2",
                                                               "auth_3", "auth_4")], na.rm = TRUE),
         trump_voter =  ifelse(presvote_trump_2020 == 1, 
                              1 , 0 ),
         trump_voter =  ifelse(is.na(trump_voter), presvote_trump_2024, trump_voter),
        trumpXauthoritarianism = trump_voter * authoritarianism
           )  -> dat


# Assuming 'electoral_contestation', 'year', 'party_identification3', and 'model' are defined
model = "f1 =~ violent + state_certify + concede +  criticize_election + new_election + undermine  + certify_occupy\n    
f2 =~  attend_march + court + recount\n"
# model = paste(model, 
#               "f1 ~", "trump_voter", "\n",
#               "f2 ~", "trump_voter"
#               )

# Perform multiple group CFA with measurement invariance constraints
fit_multi <- suppressWarnings(sem(model,
                                 data = dat,
                                 group = "trump_voter",
                                group.equal = c("loadings", "intercepts", "residuals"),
                                 missing = "fiml"))

# Compare different fits




# extract factor scores and append to data
dat <- cbind(dat, 
             lavPredict(fit_multi, type = "lv") %>% as.data.frame() %>% 
               rename(f1 = f1, f2 = f2))


# Extract parameter estimates
parameter_estimates <- parameterEstimates(fit_multi) %>% 
  filter((lhs == "f1"| lhs =="f2") & op == "~" & rhs == "trump_voter") -> mean.estimates
  

# Fitted values in lavaan
lavPredict(fit_multi,
             newdata =  dat %>% mutate(trump_voter = 1),
             type = "lv") %>%
  as.data.frame() %>%
  summarise(f1 = mean(f1),
            f2 = mean(f2)) -> fitted_values



```

The fit is quite good. 

Let's now look at the eigenvalues *within* survey wave.

### Within Each Survey Wave

First, I created a simple function to prevent recycling the same code.

```{r}
runEFA = function(factors = 2, 
                  data = electoral_contestation){
  
         df = data # Change if need be
         fit <- suppressWarnings(
                            efa(data = data,
                            nfactors = factors,
                            missing = "fiml"
           ))
       if(factors == 2) eigenvalues = summary(fit)[[10]]$nf2[[1]]$eigvals[[1]]
       if(factors == 3) eigenvalues =summary(fit)[[10]]$nf3[[1]]$eigvals[[1]]
       if(factors == 4) eigenvalues =summary(fit)[[10]]$nf4[[1]]$eigvals[[1]]
    
         eigen_df <- data.frame(
           Factor = 1:length(eigenvalues),
           Eigenvalue = eigenvalues
         )                                      
scree_plot <- ggplot(eigen_df, aes(x = Factor, y = Eigenvalue)) +
  geom_line(alpha = 0.6) +  
  geom_point(size = 3, alpha = 0.3, color = "black") + 
  labs(
    title = "Electoral Contestation\nScree Plot",
    x = "Factors",
    y = "Eigenvalue"
  ) +
  theme_minimal() + 
  # style a hell of lot better
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    axis.text = element_text(size = 10),
    axis.title = element_text(size = 12),
    plot.title = element_text(size = 14)
  ) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgrey")

         
         return(list(fit = fit, 
                     eigen_df = eigen_df, 
                     scree_plot = scree_plot))
}
electoral_contestation %>%
  select(c("state_certify", "concede","criticize_election", "attend_march", "court",  "recount", "new_election", "undermine", "violent") ) %>%
runEFA(factors = 2)
```

```{r}
options(scipen = 999, repr.plot.width = 12, repr.plot.height = 10)

var = c("state_certify", "concede","criticize_election", "attend_march", "court",  "recount", "new_election", "undermine", "violent", "survey") 
results <- list()
for (s in unique(electoral_contestation$survey)) {
        results[[s]] <-
            electoral_contestation %>%
            filter(survey == s) %>%
            select(all_of(var)) %>%
            select(!survey) %>%
              select_if(~ !all(is.na(.)))  %>%
          na.omit()

}
        
avpw1<- runEFA(factors = 2, data = results[[1]])[[3]] +
  ggplot2::ggtitle(paste("Arizona Voter Project\n(2023)"))
avpw2<- runEFA(factors = 2, data = results[[2]])[[3]] +
  ggplot2::ggtitle(paste("Arizona Voter Project\n(2024)"))
wss20<- runEFA(factors = 1, data = results[[3]])[[3]] +
  ggplot2::ggtitle(paste("Western States Survey\n(2020)"))
wss24<- runEFA(factors = 1, data = results[[4]])[[3]] +
  ggplot2::ggtitle(paste("Western States Survey\n(2024)"))
cesASU<- runEFA(factors = 1, data = results[[5]])[[3]] +
  ggplot2::ggtitle(paste("ASU CES\n(2022)"))

scree_plots <- cowplot::plot_grid(avpw1, avpw2, wss20, wss24, cesASU, ncol = 3)
scree_plots

```
These surveys have differing numbers of items, but the factor structure -- 2 -- looks pretty similar across surveys. There seems to be "conventional/traditional" factor and a "socially transgressive" factor -- newer means of electoral contestation, like "calling a new election."

Here is the correlation matrix across surveys.
```{r}
library(dplyr)


```

Note how items like "undermine" and "violent" correlated with "new election" but not with "court" or "recount." 

## Party Differences

The groups are 1 = Democrat, 2 = Independent, 3 = Republican. Republicans score highest on both forms of contestation.

```{r}
library(lavaan)
# Multiple Group Model
model <- ' f1 =~ violent + state_certify + concede +  criticize_election + new_election + undermine
           f2 =~  attend_march + court + recount'

suppressWarnings(cfa(model, 
                            data = electoral_contestation,
                            missing = "fiml",
                            group = "party_identification3",
#                           group.equal = c("loadings", "intercepts", "residuals")
           )) %>% summary(fit.measures = TRUE)

```
This is the same thing.

```{r}
electoral_contestation %>%
        mutate(
           republican = as.numeric(party_identification3 == 3),
           independent = as.numeric(party_identification3 == 2),
           democrat = as.numeric(party_identification3 == 1),
        ) -> df


model <- ' f1 =~ violent + state_certify + concede +  
                 criticize_election + new_election + undermine
           f2 =~  attend_march + court + recount
           f1 ~ independent + democrat 
           f2 ~ independent + democrat'

suppressWarnings(sem(model, 
                            data = df,
                            missing = "fiml",
           )) %>% summary(fit.measures = TRUE)

```
```


## Appendix
This isn't pretty. We'd need to clean this up if we decide to present this.


```{r}
vars = c("violent", "state_certify", "concede", "criticize_election", "attend_march", "court", "recount", "new_election", "undermine")

for (s in unique(electoral_contestation$survey)) {
  for (v in vars) {
    temp_data <- electoral_contestation %>%
      filter(survey == s) %>%
      select(!!sym(v)) # Use sym() to select the column

    if (nrow(temp_data) > 0) { # Check if there is data to plot
      p <- ggplot(temp_data, aes(x = !!sym(v))) + # Use sym() to map the column
        geom_histogram(aes(y = ..density..), binwidth = 1, fill = "lightblue", color = "black", alpha = 0.5) +
        geom_density(color = "red", bw = 0.5) +
        labs(title = paste("Variable", v, "Survey", s),
             x = v,
             y = "Density") +
        theme_minimal()
      print(p)
    } else {
      print(paste("No data to plot for", v, "in survey", s))
    }
  }
}

```


