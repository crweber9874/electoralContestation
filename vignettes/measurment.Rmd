---
title: "The Measurement Properties of Electoral Contestation"
header-includes:
    - \usepackage{setspace}\onehalfspacing
author: "Chris Weber"
date: "2025-03-03"
indent: true
output:
  pdf_document: default
---

## Introduction

We begin with a descriptive question: What types of actions do Americans deem acceptable when someone disagrees with the results of an election? Here we focus on levels of support for various actions such as protesting, criticizing election integrity, burning the American flag, ballot recounts, or challenging the outcome in the courts. Moreover, we are interested in understanding the underlying structure of contestation preferences. Is a construct like contestation multidimensional?

On one hand, we might expect that contestation behaviors reside on a single underlying dimension, anchored by a preference for contestation behaviors on one pole, and an opposition to these behaviors at the other pole. However, there are several reasons to expect more nuance, due primarily to different norms surrounding such behaviors. For instance, while recounting ballots and supporting legal means to contest an election are common and generally perceived-to-be acceptable behaviors, attending a march or burning the flag are seen as more active and potentially transgressive behaviors. Contestation behaviors may be effectively disaggregated into forms that pose a relatively high cost for individual citizens (i.e, require action) versus forms of contestation that are passive and impose a low cost for citizens. They can also be viewed as a continuum of behaviors that range from less to more normatively acceptable.

\subsection{Measuring Support for Contestation Behaviors}

We measure support for behaviors aimed at contesting election results with a question battery that captures some of the most prominent ways election results are contested. Respondents were asked,

\`\`Many people are unhappy with the outcomes of elections. How much do you support or oppose each of the following behaviors when people are unhappy with the outcome of an election?''

$\bullet$ Attend a march or demonstration [, even if it might turn chaotic or dangerous]

$\bullet$ Publicly criticize the integrity or fairness of the election [on social media]

$\bullet$ Burn the American flag

$\bullet$ Support ballot recounts

$\bullet$ Contest the outcome in the courts

Respondents were asked to rate their support for each behavior on a 5-point scale, ranging from 1 (strongly support) to 5 (strongly oppose).

## Recoding and Scaling

We rely on six data sets in this project. The **Western States Survey** conducted in both 2020 and 2024. The **Arizona Voter Project** election surveys, conducted in 2023 and 2024. And the 2022 Congressional Election Study BYU module and the 2022 Congressional Election Study ASU module.

The $\texttt{electoralContestation}$ package includes a number of helper functions to clean and recode these data. Downloading the package comes with the data $\texttt{electoral_contestation}$. The total data size is approximately 11,000 respondents.

```{r}
rm(list = ls())
# Install from repository
#devtools::install_github("crweber9874/electoralContestation")
library(electoralContestation)
library(dplyr)
library(lavaan)
#
```
From here, let's create a truncated "master" data file, with common content.

In structural equation modeling, full information maximum likelihood (FIML) is frequently used when data are Missing At Random (MAR). FIML involves calculating the likelihood function based on the observed data, then it integrates out the missing values. The likelihood is calculated based on the information available. Insofar as the data are "missing at random" (MAR), FIML can be a useful way in an SEM to handle missing data, and it's not altogether different from the assumptions underlying imputation methods. I am basically using all the information available, across the six studies, using nine contestation items.


* Attend a march or demonstration (WSS20[1/2], WSS24, AVPW1, AVPW2, ASU, BYU)
* Burning the American flag (WSS20, WSS24, AVPW1, AVPW2, ASU, BYU)
* Contest the outcome in the courts (WSS20, WSS24, AVPW1, AVPW2, ASU, BYU)
* Support ballot recounts (WSS20, WSS24, AVPW1, AVPW2, ASU, BYU)
* Publicly criticize the integrity or fairness of the election (WSS20[1/2], WSS24, AVPW1, AVPW2, ASU, BYU)
* Engaging in violent acts (WSS24, ASU[Pre], BYU [Post, Control])
* Public officials choosing to certify the election results (AVPW1, AVPW2)
* Refusing to concede an election defeat (AVPW1, AVPW2)
* Call a new election (AVPW1, AVPW2)
* Undermine the election process (WSS24)

Here is how this is done in lavaan. Let's just print out the output for a 1 through three factor model

```{r}


fit <- suppressWarnings(efa(data = electoral_contestation[,c("violent",
                                                       "state_certify",
                                                       "concede",
                                                       "criticize_election",
                                                       "attend_march",
                                                       "court",
                                                       "recount",
                                                       "new_election",
                                                       "undermine")],
                            nfactors = 2,
                            missing = "fiml",
           ))

summary(fit, fit.measures = TRUE, fit.measures = TRUE)
```


```{r}


fit <- suppressWarnings(efa(data = electoral_contestation[,c("violent",
                                                       "state_certify",
                                                       "concede",
                                                       "criticize_election",
                                                       "attend_march",
                                                       "court",
                                                       "undermine",
                                                       "recount",
                                                       "new_election")],
                            nfactors = 3,
                            missing = "fiml",
           ))
                                                       
eigenvalues = summary(fit)[[10]]$nf3[[1]]$eigvals[[1]]

eigen_df <- data.frame(
  Factor = 1:length(eigenvalues),
  Eigenvalue = eigenvalues
)


# Scree plot using ggplot2 (dots connected by lines)
scree_plot <- ggplot(eigen_df, aes(x = Factor, y = Eigenvalue)) +
  geom_line(alpha = 0.6) +  # Connect the dots with lines
  geom_point(size = 6, alpha = 0.3, color = "black") + # Add dots at each point
  labs(
    title = "Electoral Contestation\nScree Plot",
    x = "Factors",
    y = "Eigenvalue"
  ) +
  theme_minimal() + 
  # style a hell of lot better
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14),
    plot.title = element_text(size = 16)
  ) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgrey")

scree_plot
```

The two factor makes sense here -- both eigenvalues exceed the (arbitrary) cut point and the "elbow" is also at 2.


Here's the fit for a confirmatory factor model, following this structure


```{r}



# ordinal_data = c("burn_flag", "court", "recount", "criticize_election", "attend_march",
#                 "violent", "concede", "state_certify", "new_election" )

model <- ' f1 =~ violent + state_certify + concede +  criticize_election + new_election + undermine
           f2 =~  attend_march + court + recount'



fit <- suppressWarnings(cfa(model, data = electoral_contestation,
           missing = "fiml"
           ))

# mod indices
summary(fit, fit.measures = TRUE)
```

### Within Each Survey Wave

Make the model a function
```{r}
runEFA = function(factors = 2, 
                  data = electoral_contestation){
  
  
         df = data
  
         fit <- suppressWarnings(
                            efa(data = data,
                            nfactors = factors,
                            missing = "fiml"
           ))
       if(factors == 2) eigenvalues = summary(fit)[[10]]$nf2[[1]]$eigvals[[1]]
       if(factors == 3) eigenvalues =summary(fit)[[10]]$nf3[[1]]$eigvals[[1]]
       if(factors == 4) eigenvalues =summary(fit)[[10]]$nf4[[1]]$eigvals[[1]]
    
         eigen_df <- data.frame(
           Factor = 1:length(eigenvalues),
           Eigenvalue = eigenvalues
         )                                      
     # Scree plot using ggplot2 (dots connected by lines)
scree_plot <- ggplot(eigen_df, aes(x = Factor, y = Eigenvalue)) +
  geom_line(alpha = 0.6) +  # Connect the dots with lines
  geom_point(size = 6, alpha = 0.3, color = "black") + # Add dots at each point
  labs(
    title = "Electoral Contestation\nScree Plot",
    x = "Factors",
    y = "Eigenvalue"
  ) +
  theme_minimal() + 
  # style a hell of lot better
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "black"),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14),
    plot.title = element_text(size = 16)
  ) + 
  geom_hline(yintercept = 1, linetype = "dashed", color = "darkgrey")

         
         return(list(fit = fit, 
                     eigen_df = eigen_df, 
                     scree_plot = scree_plot))
}
# test
electoral_contestation %>%
  select(c("state_certify", "concede","criticize_election", "attend_march", "court",  "recount", "new_election", "undermine", "violent") ) %>%
runEFA(factors = 2)
```

```{r}

var = c("state_certify", "concede","criticize_election", "attend_march", "court",  "recount", "new_election", "undermine", "violent", "survey") 
results <- list()
for (s in unique(electoral_contestation$survey)) {
        results[[s]] <- 
            electoral_contestation %>%
            filter(survey == s) 
            print(s)
}


runEFA(factors = 2)[[3]] + 
            ggplot2::ggtitle(paste("Scree Plot for", s)) # Add survey title



 %>%
            runEFA(factors = 2)[[3]] + 
            ggplot2::ggtitle(paste("Scree Plot for", s)) # Add survey title

   scree_plots[[survey]] <- result$scree_plot + 
      ggplot2::ggtitle(paste("Scree Plot for", survey)) # Add survey title


for (s in unique(electoral_contestation$survey)) {
  data_subset = electoral_contestation %>%
  filter(survey == "wss24") %>% 
  select(all_of(contestation_names)) 
  print(dim(data_subset))
  
  result <- runEFA(factors = 2, data = data_subset)
  scree_plots[[survey]] <- result$scree_plot + 
    ggplot2::ggtitle(paste("Scree Plot for", survey)) # Add survey title
}


```
# Need to be able to see a scree plot for each election
# Choose the 
```{r}
# Cycle through the surveys and save the scree_plot to a list
library(dplyr)
scree_plots <- list()
for (s in unique(electoral_contestation$survey)) {
  data_subset <- electoral_contestation %>% dplyr::filter(survey == s)
  print(dim(data_subset))
  result <- runEFA(factors = 3, data = data_subset)
  scree_plots[[survey]] <- result$scree_plot + 
    ggplot2::ggtitle(paste("Scree Plot for", survey)) # Add survey title
}

```

Seems to fit the idea of a "traditional" means of protest? 
```{r}
electoral_contestation %>%
  select("burn_flag", "court", "criticize_election", "attend_march", "recount") %>%
  # deal with NA
  na.omit() %>%
  cor()
```

Testing for measurement invariance across party categories.

```{r}
# Configural Invariance: This assumes total variation of parameters across groups
fit_configural <- cfa(model, data = electoral_contestation, ordered = ordinal_data, group = "party3")

# Scalar Invariance: This assumes equal factor loadings and intercepts across groups
fit_scalar2 <- cfa(model, data = electoral_contestation, ordered = ordinal_data, group = "party3", group.equal = c("loadings", "thresholds", "means", "residuals"))
# summary(fit_scalar, fit.measures = TRUE)

# Compare models
anova(fit_configural, fit_scalar2)
```

There fairly substantial differences in comparing the fully variant model to the one that is equal across partisan groups. There seems to be measurement variance. Here is the fully varying model -- though note that without some common items it's not really possible to compare estimates

```{r}
summary(fit_configural, fit.measures = TRUE)
```

```{r}
electoral_contestation$survey <- as.character(electoral_contestation$survey)
# one hot encode survey
electoral_contestation <- electoral_contestation %>%
  mutate(wss20 = as.numeric(survey == "wss20"),
         wss24 = as.numeric(survey == "wss24"),
         avpw1 = as.numeric(survey == "avpw1"),
         avpw2 = as.numeric(survey == "avpw2"))


model <- ' f1 =~ court + recount + criticize_election +  attend_march + burn_flag
           court ~~ recount
           f1 ~ wss20 + wss24 + avpw1'

fit_modified <- sem(model, data = electoral_contestation,
           ordered = ordinal_data,
           group = "party3"
           ) 
summary(fit_modified, fit.measures = TRUE)

```
